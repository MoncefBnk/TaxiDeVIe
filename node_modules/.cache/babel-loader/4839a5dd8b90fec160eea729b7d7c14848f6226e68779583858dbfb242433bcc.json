{"ast":null,"code":"import \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nvar instanceOfAny = function instanceOfAny(object, constructors) {\n  return constructors.some(function (c) {\n    return object instanceof c;\n  });\n};\nvar idbProxyableTypes;\nvar cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype[\"continue\"], IDBCursor.prototype.continuePrimaryKey]);\n}\nvar cursorRequestMap = new WeakMap();\nvar transactionDoneMap = new WeakMap();\nvar transactionStoreNamesMap = new WeakMap();\nvar transformCache = new WeakMap();\nvar reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  var promise = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    var success = function success() {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    var error = function error() {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(function (value) {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n  })[\"catch\"](function () {});\n  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  var done = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    var complete = function complete() {\n      resolve();\n      unlisten();\n    };\n    var error = function error() {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nvar idbProxyTraps = {\n  get: function get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Polyfill for objectStoreNames because of Edge.\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set: function set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has: function has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var tx = func.call.apply(func, [unwrap(this), storeNames].concat(args));\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  var newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nvar unwrap = function unwrap(value) {\n  return reverseTransformCache.get(value);\n};\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","map":{"version":3,"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","storeNames","_len","arguments","length","args","Array","_key","call","apply","unwrap","concat","sort","includes","_len2","_key2","_len3","_key3","transformCachableValue","Proxy","IDBRequest","newValue","a","i","r","u","w"],"sources":["C:/Users/Clement/Desktop/ProjetS4/taxi-de-vie/node_modules/idb/build/wrap-idb-value.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\r\n\r\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    set(target, prop, value) {\r\n        target[prop] = value;\r\n        return true;\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction replaceTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\r\n\r\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}